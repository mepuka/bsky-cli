{"id":"skygent-bsky-1at","title":"Wire derivation layers into CLI with proper dependencies","description":"**Plan Reference**: /Users/pooks/.claude/plans/cosmic-popping-cake.md - Phase 1, Layers section (lines 504-537)\n\n## Goal\nAdd derivation services to CliLive layer with proper dependency wiring. Ensure FilterRuntime has all required effectful service dependencies.\n\n## Pre-Implementation Research (CRITICAL)\n\n### 1. Review Existing Code\n- Read src/cli/layers.ts - understand current layer composition\n- Read src/services/filter-runtime.ts - understand runtime dependencies\n- Study Layer.provideMerge vs Layer.provide patterns\n- Review existing runtimeLayer wiring (lines 81-104 in current layers.ts)\n\n### 2. Effect Documentation Research\nUse effect-docs MCP extensively:\n```\neffect-docs search \"Layer.provide\"\neffect-docs search \"Layer.provideMerge\"\neffect-docs search \"Layer.mergeAll\"\neffect-docs search \"layer composition\"\neffect-docs search \"service dependencies\"\n```\n\nStudy deeply:\n- Layer.provide vs Layer.provideMerge (critical difference!)\n- Layer.mergeAll for multiple layers\n- Dependency resolution order\n- Circular dependency detection\n\n### 3. Review Effect Source (CRITICAL)\nStudy Layer implementation:\n- How provide chains dependencies\n- How merge combines layers\n- When to use provide vs provideMerge\n- Error messages for missing dependencies\n\n## Implementation\n\n### File: src/cli/layers.ts (modify)\n\nAdd three new layers following existing patterns:\n\n```typescript\n// ViewCheckpointStore depends on KeyValueStore (via storageLayer)\nconst viewCheckpointLayer = ViewCheckpointStore.layer.pipe(\n  Layer.provideMerge(storageLayer)\n);\n\n// LineageStore depends on KeyValueStore (via storageLayer)\nconst lineageLayer = LineageStore.layer.pipe(\n  Layer.provideMerge(storageLayer)\n);\n\n// DerivationEngine has MANY dependencies - wire carefully\nconst derivationLayer = DerivationEngine.layer.pipe(\n  Layer.provideMerge(eventLogLayer),      // StoreEventLog\n  Layer.provideMerge(writerLayer),        // StoreWriter\n  Layer.provideMerge(indexLayer),         // StoreIndex\n  Layer.provideMerge(FilterCompiler.layer),\n  Layer.provideMerge(runtimeLayer),       // FilterRuntime with LLM/Link/Trending layers\n  Layer.provideMerge(viewCheckpointLayer), // ViewCheckpointStore\n  Layer.provideMerge(lineageLayer)        // LineageStore\n);\n\n// DerivationValidator needs checkpoint store, event log, store manager\nconst derivationValidatorLayer = DerivationValidator.layer.pipe(\n  Layer.provideMerge(viewCheckpointLayer),\n  Layer.provideMerge(eventLogLayer),\n  Layer.provideMerge(managerLayer)\n);\n\n// Add to CliLive exports\nexport const CliLive = Layer.mergeAll(\n  // ... existing layers\n  viewCheckpointLayer,\n  lineageLayer,\n  derivationLayer,\n  derivationValidatorLayer\n);\n```\n\n## Critical Considerations\n- FilterRuntime already has llmDecisionLayer + linkValidatorLayer + trendingTopicsLayer wired (see existing runtimeLayer)\n- Use Layer.provideMerge for all dependencies (NOT Layer.provide)\n- Order matters: dependencies must be provided before dependents\n- DerivationEngine needs ALL services it yields*\n- Check compilation errors for missing dependencies\n\n## Acceptance Criteria\n- [ ] All layers compile without errors\n- [ ] No missing dependency errors at runtime\n- [ ] viewCheckpointLayer wired correctly\n- [ ] lineageLayer wired correctly\n- [ ] derivationLayer wired with all 7 dependencies\n- [ ] derivationValidatorLayer wired with 3 dependencies\n- [ ] All layers added to CliLive\n- [ ] No circular dependencies\n- [ ] Follows existing layer patterns\n\n## Verification\n```bash\n# Test compilation\nbun run build\n\n# Test runtime (should not error about missing services)\nskygent derive --help\n\n# Test full pipeline\nskygent derive test-source test-target --filter-json '{\"_tag\":\"All\"}'\n# Should not error with \"service not found\"\n```\n\n## Related\n- Parent: #1\n- Depends on: skygent-bsky-293, skygent-bsky-hm1, skygent-bsky-ijd, skygent-bsky-5h2\n- Blocks: skygent-bsky testing","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-26T14:21:44.333964-06:00","updated_at":"2026-01-26T14:21:44.333964-06:00","dependencies":[{"issue_id":"skygent-bsky-1at","depends_on_id":"skygent-bsky-5h2","type":"blocks","created_at":"2026-01-26T14:22:49.790236-06:00","created_by":"daemon"},{"issue_id":"skygent-bsky-1at","depends_on_id":"skygent-bsky-hm1","type":"blocks","created_at":"2026-01-26T14:22:49.913018-06:00","created_by":"daemon"}]}
{"id":"skygent-bsky-293","title":"Implement ViewCheckpointStore and LineageStore services","description":"**Plan Reference**: /Users/pooks/.claude/plans/cosmic-popping-cake.md - Phase 2, sections 3.1\n\n## Goal\nCreate KV-backed stores for persisting DerivationCheckpoint and StoreLineage. Follow existing service patterns.\n\n## Pre-Implementation Research\n\n### 1. Review Existing Code\n- Read src/services/store-manager.ts - understand KV service pattern\n- Read src/services/sync-checkpoint-store.ts (if exists) - checkpoint pattern\n- Study Context.Tag service definition pattern\n- Review Layer.effect composition\n\n### 2. Effect Documentation Research\nUse effect-docs MCP:\n```\neffect-docs search \"Context.Tag\"\neffect-docs search \"Layer composition\"\neffect-docs search \"service dependencies\"\neffect-docs search \"Effect.fn\"\n```\n\nStudy:\n- Context.Tag for service definition\n- Layer.effect for service implementation\n- Service dependency injection\n- Effect.fn() for traced operations\n\n### 3. Review Effect Source\nCheck Context and Layer implementations:\n- Tag creation patterns\n- Layer dependency resolution\n- Service lifetime management\n\n## Implementation\n\n### File: src/services/view-checkpoint-store.ts (new)\n```typescript\nimport { Context, Effect, Layer, Option } from \"effect\";\nimport { KeyValueStore } from \"@effect/platform\";\nimport { DerivationCheckpoint } from \"../domain/derivation.js\";\nimport { StoreName } from \"../domain/primitives.js\";\nimport { StoreIoError } from \"../domain/errors.js\";\n\nconst checkpointKey = (viewName: StoreName, sourceName: StoreName) =\u003e\n  `stores/${viewName}/checkpoints/derivation/${sourceName}`;\n\nexport class ViewCheckpointStore extends Context.Tag(\"@skygent/ViewCheckpointStore\")\u003c\n  ViewCheckpointStore,\n  {\n    readonly load: (\n      viewName: StoreName,\n      sourceName: StoreName\n    ) =\u003e Effect.Effect\u003cOption.Option\u003cDerivationCheckpoint\u003e, StoreIoError\u003e;\n    readonly save: (\n      checkpoint: DerivationCheckpoint\n    ) =\u003e Effect.Effect\u003cvoid, StoreIoError\u003e;\n  }\n\u003e() {\n  static readonly layer = Layer.effect(\n    ViewCheckpointStore,\n    Effect.gen(function* () {\n      const kv = yield* KeyValueStore.KeyValueStore;\n      const checkpoints = kv.forSchema(DerivationCheckpoint);\n\n      const load = Effect.fn(\"ViewCheckpointStore.load\")(\n        (viewName: StoreName, sourceName: StoreName) =\u003e\n          checkpoints.get(checkpointKey(viewName, sourceName)).pipe(\n            Effect.mapError((e) =\u003e StoreIoError.make({ ... }))\n          )\n      );\n\n      const save = Effect.fn(\"ViewCheckpointStore.save\")(\n        (checkpoint: DerivationCheckpoint) =\u003e\n          checkpoints.set(\n            checkpointKey(checkpoint.viewName, checkpoint.sourceStore),\n            checkpoint\n          ).pipe(\n            Effect.mapError((e) =\u003e StoreIoError.make({ ... }))\n          )\n      );\n\n      return ViewCheckpointStore.of({ load, save });\n    })\n  );\n}\n```\n\n### File: src/services/lineage-store.ts (new)\nSimilar pattern for StoreLineage - see plan section 2.2\n\n## Critical Considerations\n- Use Effect.fn() for all operations (tracing)\n- Map KV errors to StoreIoError\n- Use forSchema for type-safe KV access\n- Follow naming conventions: service-name.method\n\n## Acceptance Criteria\n- [ ] ViewCheckpointStore compiles without errors\n- [ ] LineageStore compiles without errors\n- [ ] Both services use Context.Tag pattern\n- [ ] Layer.effect properly wires dependencies\n- [ ] Effect.fn() used for all operations\n- [ ] Errors mapped to domain types\n- [ ] No unsafe Effect patterns\n\n## Verification\n```bash\n# Test service creation\nbun test tests/services/view-checkpoint-store.test.ts\nbun test tests/services/lineage-store.test.ts\n```\n\n## Related\n- Parent: #1\n- Depends on: skygent-bsky-9ed (domain types)\n- Blocks: skygent-bsky DerivationEngine","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-26T14:18:25.132359-06:00","updated_at":"2026-01-26T14:18:25.132359-06:00","dependencies":[{"issue_id":"skygent-bsky-293","depends_on_id":"skygent-bsky-9ed","type":"blocks","created_at":"2026-01-26T14:22:49.15138-06:00","created_by":"daemon"}]}
{"id":"skygent-bsky-44c","title":"Add unit and integration tests for store derivation","description":"**Plan Reference**: /Users/pooks/.claude/plans/cosmic-popping-cake.md - Testing Strategy section (lines 625-640)\n\n## Goal\nComprehensive test coverage for derivation: unit tests for services, integration tests for end-to-end workflows, property tests for invariants.\n\n## Pre-Implementation Research\n\n### 1. Review Existing Code\n- Read tests/services/*.test.ts - understand test patterns\n- Read tests/integration/*.test.ts - understand integration test structure\n- Study bun:test API (describe, test, expect)\n- Review test layer composition patterns\n\n### 2. Effect Documentation Research\nUse effect-docs MCP:\n```\neffect-docs search \"Effect.runPromise\"\neffect-docs search \"Layer.provide testing\"\neffect-docs search \"test fixtures\"\n```\n\nStudy:\n- Running Effect in tests\n- Test layer composition\n- Mock services\n- Effect.gen in tests\n\n### 3. Review Bun Test Docs\nStudy bun:test:\n- async test patterns\n- expect assertions\n- describe/test structure\n\n## Implementation\n\n### File: tests/services/derivation-engine.test.ts (new)\n\n```typescript\nimport { describe, test, expect } from \"bun:test\";\nimport { Effect, Layer } from \"effect\";\nimport { DerivationEngine } from \"../../src/services/derivation-engine.js\";\n\ndescribe(\"DerivationEngine\", () =\u003e {\n  test(\"derives filtered posts from source\", async () =\u003e {\n    // Create test stores with mock data\n    // Apply Hashtag filter\n    // Verify target has only matching posts\n  });\n\n  test(\"propagates ALL PostDelete events unfiltered\", async () =\u003e {\n    // Create source with mixed PostUpsert and PostDelete\n    // Derive with Hashtag filter\n    // Verify ALL deletes in target (even non-matching hashtags)\n    // Verify only matching PostUpsert in target\n  });\n\n  test(\"idempotence: derive twice yields same result\", async () =\u003e {\n    // Derive source to target\n    // Derive again\n    // Verify eventsProcessed = 0 on second run\n    // Verify target has same posts\n  });\n\n  test(\"EventTime mode rejects effectful filters\", async () =\u003e {\n    // Try derive with Llm filter in EventTime mode\n    // Expect DerivationError\n  });\n\n  test(\"DeriveTime mode accepts effectful filters\", async () =\u003e {\n    // Derive with Llm filter in DeriveTime mode\n    // Should succeed (even if LLM calls fail, they're caught)\n  });\n\n  test(\"checkpoint enables incremental derivation\", async () =\u003e {\n    // Derive 100 posts\n    // Add 10 more to source\n    // Derive again\n    // Verify eventsProcessed = 10 (not 110)\n  });\n\n  test(\"filter change invalidates checkpoint\", async () =\u003e {\n    // Derive with Hashtag #tech\n    // Derive with Hashtag #ai (different filter)\n    // Should error without --reset\n  });\n\n  test(\"localeCompare used for EventId filtering\", async () =\u003e {\n    // Create checkpoint with lastSourceEventId\n    // Verify stream filters using localeCompare\n    // Test with ULID edge cases\n  });\n});\n```\n\n### File: tests/integration/derive-full.test.ts (new)\n\n```typescript\nimport { describe, test, expect } from \"bun:test\";\n\ndescribe(\"Store Derivation End-to-End\", () =\u003e {\n  test(\"derive creates filtered store\", async () =\u003e {\n    // Sync timeline to source store\n    // Run: skygent derive source target --filter-json {...}\n    // Query target\n    // Verify subset of source\n  });\n\n  test(\"delete propagation maintains consistency\", async () =\u003e {\n    // Create source with posts\n    // Manually add PostDelete event\n    // Derive to target\n    // Verify PostDelete in target event log\n    // Verify deleted URI not in target index\n  });\n\n  test(\"view status detects staleness\", async () =\u003e {\n    // Derive source to target\n    // Run: skygent view status target source\n    // Expect: \"ready\"\n    // Add events to source\n    // Run: skygent view status target source\n    // Expect: \"stale\"\n  });\n\n  test(\"--reset clears and rebuilds\", async () =\u003e {\n    // Derive with filter A\n    // Derive with filter B --reset --yes\n    // Verify old posts cleared\n    // Verify new filter applied\n  });\n});\n```\n\n### Property Tests\n\n```typescript\ndescribe(\"Derivation Invariants\", () =\u003e {\n  test(\"count invariant: processed = matched + skipped\", async () =\u003e {\n    // Property: eventsProcessed = eventsMatched + eventsSkipped\n    // Test with random filters and post sets\n  });\n\n  test(\"idempotence: derive(S,T,F) twice = derive(S,T,F) once\", async () =\u003e {\n    // Run derivation twice\n    // Compare final states\n    // Should be identical\n  });\n});\n```\n\n## Critical Considerations\n- Use Effect.runPromise for async tests\n- Provide test layers (mock stores if needed)\n- Test error cases (missing stores, invalid filters)\n- Verify PostDelete propagation explicitly\n- Test ULID localeCompare edge cases\n\n## Acceptance Criteria\n- [ ] DerivationEngine unit tests pass\n- [ ] Integration tests pass\n- [ ] Property tests pass\n- [ ] PostDelete propagation verified\n- [ ] Idempotence verified\n- [ ] EventTime/DeriveTime modes tested\n- [ ] Checkpoint incremental derivation tested\n- [ ] Filter change detection tested\n- [ ] 85%+ code coverage\n\n## Verification\n```bash\n# Run all tests\nbun test\n\n# Run specific tests\nbun test tests/services/derivation-engine.test.ts\nbun test tests/integration/derive-full.test.ts\n\n# Coverage\nbun test --coverage\n```\n\n## Related\n- Parent: #1\n- Depends on: All previous issues (9ed, uej, 293, hm1, ijd, 5h2, 1at)\n- Blocks: Manual QA and release","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-26T14:22:18.052925-06:00","updated_at":"2026-01-26T14:22:18.052925-06:00","dependencies":[{"issue_id":"skygent-bsky-44c","depends_on_id":"skygent-bsky-1at","type":"blocks","created_at":"2026-01-26T14:22:50.036921-06:00","created_by":"daemon"}]}
{"id":"skygent-bsky-5h2","title":"Add derive and view CLI commands with filter change detection","description":"**Plan Reference**: /Users/pooks/.claude/plans/cosmic-popping-cake.md - Phase 1, sections 2.1, 2.2, 2.3, 2.4 (lines 439-500)\n\n## Goal\nImplement skygent derive and skygent view commands with proper validation, error messages, and user confirmation prompts.\n\n## Pre-Implementation Research\n\n### 1. Review Existing Code (CRITICAL)\n- Read src/cli/sync.ts - understand command structure\n- Read src/cli/query.ts - understand Options and Args patterns\n- Read src/cli/store.ts - understand store show output\n- Read src/cli/errors.ts - understand CliInputError pattern\n- Study @effect/cli command composition\n\n### 2. Effect Documentation Research\nUse effect-docs MCP:\n```\neffect-docs search \"@effect/cli Command\"\neffect-docs search \"Options.text\"\neffect-docs search \"Options.choice\"\neffect-docs search \"Options.boolean\"\neffect-docs search \"Args.text\"\n```\n\nStudy:\n- Command.make patterns\n- Options validation\n- Args with Schema\n- Command composition\n\n### 3. Review @effect/cli Source\nCheck Command implementation:\n- withDescription pattern\n- withExamples usage\n- Subcommand composition\n\n## Implementation\n\n### File: src/cli/derive.ts (new)\nKey sections from plan lines 450-482:\n\n```typescript\nconst filterOption = Options.text(\"filter-json\").pipe(Options.optional);\nconst modeOption = Options.choice(\"mode\", [\"event-time\", \"derive-time\"]).pipe(\n  Options.withDefault(\"event-time\" as const)\n);\nconst resetFlag = Options.boolean(\"reset\");\nconst yesFlag = Options.boolean(\"yes\").pipe(Options.withAlias(\"y\"));\n\n// EventTime guard for effectful filters\nif (mode === \"event-time\" \u0026\u0026 isEffectfulFilter(filterExpr)) {\n  return yield* CliInputError.make({\n    message: \"EventTime mode does not allow Llm/Trending/HasValidLinks. Use --mode derive-time.\",\n    cause: filterExpr\n  });\n}\n\n// Reset requires --yes\nif (reset \u0026\u0026 !yes) {\n  return yield* CliInputError.make({\n    message: \"--reset is destructive. Re-run with --yes to confirm.\",\n    cause: \"reset-without-yes\"\n  });\n}\n\n// Filter change detection\nconst checkpointOption = yield* checkpoints.load(targetRef.name, sourceRef.name);\nif (Option.isSome(checkpointOption)) {\n  const checkpoint = checkpointOption.value;\n  if (checkpoint.filterHash !== filterHash \u0026\u0026 !reset) {\n    return yield* CliInputError.make({\n      message: [\n        `Filter changed for derived store \"${target}\".`,\n        ``,\n        `Current: ${checkpoint.filterHash}`,\n        `New:     ${filterHash}`,\n        ``,\n        `Use --reset --yes to rebuild, or omit flag to keep existing filter.`\n      ].join(\"\\n\"),\n      cause: { oldHash: checkpoint.filterHash, newHash: filterHash }\n    });\n  }\n}\n```\n\n### File: src/cli/view.ts (new)\nSimple status command using DerivationValidator:\n```typescript\nconst viewStatus = Command.make(\n  \"status\",\n  { view: Args.text({ name: \"view\" }).pipe(Args.withSchema(StoreName)),\n    source: Args.text({ name: \"source\" }).pipe(Args.withSchema(StoreName)) },\n  ({ view, source }) =\u003e\n    Effect.gen(function* () {\n      const validator = yield* DerivationValidator;\n      const isStale = yield* validator.isStale(view, source);\n      \n      yield* writeJson({\n        view,\n        source,\n        status: isStale ? \"stale\" : \"ready\"\n      });\n    })\n);\n\nexport const viewCommand = Command.make(\"view\").pipe(\n  Command.withSubcommands([viewStatus])\n);\n```\n\n### File: src/cli/app.ts (modify)\nAdd commands to subcommands array.\n\n### File: src/cli/store.ts (modify)\nAdd lineage to show output - see plan lines 496-500.\n\n## Critical Considerations\n- Use CliInputError.make (NOT throw new Error)\n- Validation BEFORE calling DerivationEngine\n- Clear, actionable error messages\n- --reset requires --yes (no interactive prompts)\n- Filter change detection with helpful guidance\n- Use Effect.gen function* pattern\n\n## Acceptance Criteria\n- [ ] derive command compiles\n- [ ] view status command compiles\n- [ ] --mode flag validates choices\n- [ ] --reset requires --yes\n- [ ] EventTime mode rejects effectful filters\n- [ ] Filter changes error with clear message\n- [ ] store show displays lineage when present\n- [ ] Commands added to app.ts\n- [ ] No unsafe Effect patterns\n\n## Verification\n```bash\n# Test help\nskygent derive --help\nskygent view --help\n\n# Test derive\nskygent derive source target --filter-json '{\"_tag\":\"All\"}'\n\n# Test mode validation\nskygent derive source target --filter-json '{\"_tag\":\"Llm\",...}' --mode event-time\n# Should error\n\n# Test reset without yes\nskygent derive source target --filter-json '{\"_tag\":\"Hashtag\",\"tag\":\"#ai\"}' --reset\n# Should error\n\n# Test status\nskygent view status target source\n```\n\n## Related\n- Parent: #1\n- Depends on: skygent-bsky-hm1 (DerivationEngine), skygent-bsky-ijd (validator)\n- Blocks: skygent-bsky layer wiring","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-26T14:21:20.295814-06:00","updated_at":"2026-01-26T14:21:20.295814-06:00","dependencies":[{"issue_id":"skygent-bsky-5h2","depends_on_id":"skygent-bsky-hm1","type":"blocks","created_at":"2026-01-26T14:22:49.542732-06:00","created_by":"daemon"},{"issue_id":"skygent-bsky-5h2","depends_on_id":"skygent-bsky-ijd","type":"blocks","created_at":"2026-01-26T14:22:49.665824-06:00","created_by":"daemon"}]}
{"id":"skygent-bsky-9ed","title":"Add derivation domain types and EventMeta provenance","description":"**Plan Reference**: /Users/pooks/.claude/plans/cosmic-popping-cake.md - Phase 1, sections 1.1, 1.2, 1.3\n\n## Goal\nCreate domain types for store derivation with proper Effect Schema patterns. Add event provenance tracking to EventMeta.\n\n## Pre-Implementation Research\n\n### 1. Review Existing Code\n- Read src/domain/events.ts - understand EventMeta pattern\n- Read src/domain/store.ts - understand Schema.Class usage\n- Read src/domain/primitives.ts - understand branded types\n- Read src/domain/filter.ts - understand FilterExpr ADT structure\n\n### 2. Effect Documentation Research\nUse effect-docs MCP to research:\n```\neffect-docs search \"Schema.Class\"\neffect-docs search \"Schema.TaggedError\"\neffect-docs search \"Schema.Literal\"\neffect-docs search \"branded types\"\n```\n\nStudy:\n- Schema.Class vs Schema.Struct (when to use each)\n- .make() constructor pattern (NEVER use 'new')\n- Schema.TaggedError for domain errors\n- Schema.Literal for union types\n- Schema.optional() for optional fields\n\n### 3. Review Effect Source\nCheck @effect/schema source for:\n- TaggedError implementation patterns\n- Class constructor best practices\n- Avoid unsafe patterns (Schema.to, Schema.from without validation)\n\n## Implementation - See Plan for Full Code\n\nAcceptance Criteria in plan sections 1.1, 1.2, 1.3\n\n## Related\n- Parent: #1\n- Blocks: All other derivation work","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-26T14:14:41.526843-06:00","updated_at":"2026-01-26T14:28:25.912755-06:00","closed_at":"2026-01-26T14:28:25.912758-06:00"}
{"id":"skygent-bsky-hm1","title":"Implement DerivationEngine service with delete propagation and checkpointing","description":"**Plan Reference**: /Users/pooks/.claude/plans/cosmic-popping-cake.md - Phase 1, DerivationEngine section (lines 208-435)\n\n## Goal\nImplement core derivation logic: event replay, filter evaluation, PostDelete propagation, URI deduplication, checkpointing, and lineage tracking.\n\n## Pre-Implementation Research\n\n### 1. Review Existing Code (CRITICAL)\n- Read src/services/sync-engine.ts - understand event processing patterns\n- Read src/services/filter-runtime.ts - understand filter evaluation\n- Read src/services/filter-compiler.ts - understand FilterSpec compilation\n- Read src/services/store-writer.ts - understand event appending\n- Read src/services/store-index.ts - understand hasUri() and apply()\n- Study Stream.runFoldEffect pattern for stateful streaming\n\n### 2. Effect Documentation Research\nUse effect-docs MCP extensively:\n```\neffect-docs search \"Stream.runFoldEffect\"\neffect-docs search \"Stream.filter\"\neffect-docs search \"Clock.currentTimeMillis\"\neffect-docs search \"Schema.decodeUnknown\"\neffect-docs search \"Option.match\"\neffect-docs search \"Effect.gen function*\"\n```\n\nStudy deeply:\n- Stream processing with effects\n- runFoldEffect for accumulating state\n- Clock service for timestamps (NEVER Date.now())\n- Schema.decodeUnknown for safe timestamp creation\n- Option handling (match, flatMap, isSome, isNone)\n- Effect error propagation\n\n### 3. Review Effect Source (CRITICAL)\nStudy Stream implementation:\n- How runFoldEffect handles errors\n- State accumulation patterns\n- Filter composition\n- Early termination\n\nStudy Effect.gen:\n- yield* semantics\n- Error short-circuiting\n- Effect composition\n\n## Implementation\n\nSee plan lines 218-435 for complete code. Key sections:\n\n### EventTime Mode Guard\n```typescript\nif (options.mode === \"EventTime\" \u0026\u0026 isEffectfulFilter(filterExpr)) {\n  return yield* DerivationError.make({\n    reason: \"EventTime mode only supports pure filters. Use --mode derive-time.\",\n    sourceStore: sourceRef.name,\n    targetStore: targetRef.name\n  });\n}\n```\n\n### FilterSpec Compilation\n```typescript\nconst filterSpec = FilterSpec.make({\n  name: \"derive\",\n  expr: filterExpr,\n  output: FilterOutput.make({ path: \"derive\", json: false, markdown: false })\n});\nyield* compiler.compile(filterSpec);\nconst predicate = yield* runtime.evaluate(filterExpr);\n```\n\n### Checkpoint-Based Incremental Derivation\n```typescript\nconst startAfter = Option.flatMap(checkpointOption, (cp) =\u003e\n  cp.filterHash === filterHash \u0026\u0026 cp.evaluationMode === options.mode\n    ? cp.lastSourceEventId\n    : Option.none()\n);\n\nyield* eventLog.stream(sourceRef).pipe(\n  Stream.filter((record) =\u003e\n    Option.match(startAfter, {\n      onNone: () =\u003e true,\n      onSome: (id) =\u003e record.id.localeCompare(id) \u003e 0  // CRITICAL: localeCompare for ULID\n    })\n  ),\n  // ...\n)\n```\n\n### PostDelete Propagation (UNFILTERED)\n```typescript\nif (event._tag === \"PostDelete\") {\n  const derivedMeta = EventMeta.make({\n    ...event.meta,\n    sourceStore: sourceRef.name\n  });\n  const derivedEvent = PostDelete.make({ ...event, meta: derivedMeta });\n  const targetRecord = yield* writer.append(targetRef, derivedEvent);\n  yield* index.apply(targetRef, targetRecord);\n  return { processed: state.processed + 1, ..., deletes: state.deletes + 1, lastSourceId: nextLast };\n}\n```\n\n### URI Deduplication\n```typescript\nconst exists = yield* index.hasUri(targetRef, event.post.uri);\nif (exists) {\n  return { processed: state.processed + 1, ..., skipped: state.skipped + 1, ... };\n}\n```\n\n### Timestamp Creation (SAFE)\n```typescript\nconst endTimeMillis = yield* Clock.currentTimeMillis;\nconst timestamp = yield* Schema.decodeUnknown(Timestamp)(\n  new Date(endTimeMillis).toISOString()\n);\n```\n\n## Critical Considerations\n- NEVER use Date.now() - use Clock.currentTimeMillis\n- NEVER use 'new' for Schema.Class - use .make()\n- Use localeCompare() for ULID EventId comparison\n- ALL PostDelete events propagate (unfiltered)\n- Check hasUri() before filter evaluation (optimization)\n- Use Effect.fn() for derive method\n- Proper error mapping (DerivationError, StoreIoError, FilterError)\n\n## Acceptance Criteria\n- [ ] DerivationEngine compiles without errors\n- [ ] EventTime mode rejects effectful filters\n- [ ] DeriveTime mode accepts all filters\n- [ ] PostDelete propagates unfiltered\n- [ ] hasUri() prevents duplicates\n- [ ] Checkpointing works incrementally\n- [ ] localeCompare used for EventId comparison\n- [ ] Clock service used for timestamps\n- [ ] Lineage saved after successful derivation\n- [ ] No unsafe Effect patterns\n\n## Verification\n```bash\n# Unit tests\nbun test tests/services/derivation-engine.test.ts\n\n# Manual test\nskygent derive test-source test-target --filter-json '{\"_tag\":\"All\"}'\n```\n\n## Related\n- Parent: #1\n- Depends on: skygent-bsky-9ed, skygent-bsky-uej, skygent-bsky-293\n- Blocks: skygent-bsky CLI integration","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-26T14:18:58.68142-06:00","updated_at":"2026-01-26T14:18:58.68142-06:00","dependencies":[{"issue_id":"skygent-bsky-hm1","depends_on_id":"skygent-bsky-293","type":"blocks","created_at":"2026-01-26T14:22:49.277676-06:00","created_by":"daemon"},{"issue_id":"skygent-bsky-hm1","depends_on_id":"skygent-bsky-uej","type":"blocks","created_at":"2026-01-26T14:22:49.41326-06:00","created_by":"daemon"}]}
{"id":"skygent-bsky-ijd","title":"Implement DerivationValidator for O(1) staleness detection","description":"**Plan Reference**: /Users/pooks/.claude/plans/cosmic-popping-cake.md - Phase 2, section 3.2 (lines 549-561)\n\n## Goal\nCreate efficient staleness detection using getLastEventId() instead of O(n) stream scanning.\n\n## Pre-Implementation Research\n\n### 1. Review Existing Code\n- Read src/services/store-event-log.ts - understand getLastEventId() API\n- Read src/services/view-checkpoint-store.ts - understand checkpoint structure\n- Read src/services/store-manager.ts - understand getStore() pattern\n- Study Option handling patterns in existing services\n\n### 2. Effect Documentation Research\nUse effect-docs MCP:\n```\neffect-docs search \"Option.match\"\neffect-docs search \"Option.isNone\"\neffect-docs search \"Option.flatMap\"\neffect-docs search \"Context.Tag service\"\n```\n\nStudy:\n- Option combinators (match, flatMap, map)\n- Service composition patterns\n- Effect.fn() for tracing\n- Layer dependency injection\n\n### 3. Review Effect Source\nCheck Option implementation:\n- match vs if/else patterns\n- flatMap for chaining\n- Type-safe none handling\n\n## Implementation\n\n### File: src/services/derivation-validator.ts (new)\n```typescript\nimport { Context, Effect, Layer, Option } from \"effect\";\nimport { ViewCheckpointStore } from \"./view-checkpoint-store.js\";\nimport { StoreEventLog } from \"./store-event-log.js\";\nimport { StoreManager } from \"./store-manager.js\";\nimport { StoreName } from \"../domain/primitives.js\";\nimport { StoreIoError } from \"../domain/errors.js\";\n\nexport class DerivationValidator extends Context.Tag(\n  \"@skygent/DerivationValidator\"\n)\u003c\n  DerivationValidator,\n  {\n    readonly isStale: (\n      viewName: StoreName,\n      sourceName: StoreName\n    ) =\u003e Effect.Effect\u003cboolean, StoreIoError\u003e;\n  }\n\u003e() {\n  static readonly layer = Layer.effect(\n    DerivationValidator,\n    Effect.gen(function* () {\n      const checkpoints = yield* ViewCheckpointStore;\n      const eventLog = yield* StoreEventLog;\n      const storeManager = yield* StoreManager;\n\n      const isStale = Effect.fn(\"DerivationValidator.isStale\")(\n        (viewName: StoreName, sourceName: StoreName) =\u003e\n          Effect.gen(function* () {\n            const checkpointOption = yield* checkpoints.load(viewName, sourceName);\n\n            if (Option.isNone(checkpointOption)) {\n              return true; // Never materialized\n            }\n\n            const checkpoint = checkpointOption.value;\n\n            // O(1) optimization: use getLastEventId instead of streaming\n            const sourceRefOption = yield* storeManager.getStore(sourceName);\n            if (Option.isNone(sourceRefOption)) {\n              return false; // Source store deleted\n            }\n\n            const sourceRef = sourceRefOption.value;\n            const lastSourceIdOption = yield* eventLog.getLastEventId(sourceRef);\n\n            if (Option.isNone(lastSourceIdOption)) {\n              return false; // Source has no events\n            }\n\n            const lastSourceId = lastSourceIdOption.value;\n\n            if (Option.isNone(checkpoint.lastSourceEventId)) {\n              return true; // Checkpoint never recorded a last event\n            }\n\n            // CRITICAL: use localeCompare for ULID EventId strings\n            return lastSourceId.localeCompare(checkpoint.lastSourceEventId.value) \u003e 0;\n          })\n      );\n\n      return DerivationValidator.of({ isStale });\n    })\n  );\n}\n```\n\n## Critical Considerations\n- Use getLastEventId() NOT Stream.runLast (O(1) vs O(n))\n- Use localeCompare() for ULID string comparison\n- Handle all Option cases (none checkpoint, none source, none events)\n- Use Effect.fn() for tracing\n- Map errors to StoreIoError\n\n## Acceptance Criteria\n- [ ] DerivationValidator compiles\n- [ ] isStale() returns true when source has new events\n- [ ] isStale() returns false when up-to-date\n- [ ] isStale() returns true when never materialized\n- [ ] isStale() returns false when source deleted/empty\n- [ ] Uses getLastEventId (O(1) optimization)\n- [ ] localeCompare used for EventId comparison\n- [ ] Effect.fn() used\n- [ ] No unsafe patterns\n\n## Verification\n```bash\n# Unit test\nbun test tests/services/derivation-validator.test.ts\n\n# Manual test\nskygent derive source target --filter-json '{\"_tag\":\"All\"}'\nskygent view status target source  # Should show \"ready\"\nskygent sync timeline --store source --limit 10\nskygent view status target source  # Should show \"stale\"\n```\n\n## Related\n- Parent: #1\n- Depends on: skygent-bsky-uej (getLastEventId), skygent-bsky-293 (checkpoint store)\n- Blocks: skygent-bsky CLI view command","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-26T14:19:46.385986-06:00","updated_at":"2026-01-26T14:19:46.385986-06:00","dependencies":[{"issue_id":"skygent-bsky-ijd","depends_on_id":"skygent-bsky-uej","type":"blocks","created_at":"2026-01-26T14:22:49.026343-06:00","created_by":"daemon"}]}
{"id":"skygent-bsky-uej","title":"Add last event ID tracking to StoreWriter and StoreEventLog","description":"**Plan Reference**: /Users/pooks/.claude/plans/cosmic-popping-cake.md - Phase 1, sections 1.4\n\n## Goal\nAdd O(1) last event ID tracking for efficient staleness detection. Store last EventId in KV store when events are appended.\n\n## Pre-Implementation Research\n\n### 1. Review Existing Code\n- Read src/services/store-writer.ts - understand append() implementation\n- Read src/services/store-event-log.ts - understand stream() and clear()\n- Read src/services/store-index.ts - understand KeyValueStore.prefix pattern\n- Review how EventId (ULID) is generated and stored\n\n### 2. Effect Documentation Research\nUse effect-docs MCP:\n```\neffect-docs search \"KeyValueStore\"\neffect-docs search \"Effect.gen\"\neffect-docs search \"Layer.effect\"\n```\n\nStudy:\n- KeyValueStore.prefix usage for scoped KV access\n- forSchema pattern for typed KV operations\n- Effect error handling in services\n- Layer composition patterns\n\n### 3. Review Effect Source\nCheck KeyValueStore implementation:\n- How prefix scoping works\n- Atomic write guarantees\n- Error handling patterns\n\n## Implementation\n\n### File: src/services/store-writer.ts (modify)\nAdd KV key for last event ID:\n```typescript\nconst lastEventIdKey = \"events/last-id\";\n\n// in layer setup:\nconst lastEventId = kv.forSchema(EventId);\n\n// inside append() after writing event:\nconst storeLastEventId = KeyValueStore.prefix(lastEventId, prefix);\nyield* storeEvents.set(key, record);\nyield* storeLastEventId.set(lastEventIdKey, record.id); // NEW\n```\n\n### File: src/services/store-event-log.ts (modify)\nExpose getLastEventId and clear it:\n```typescript\n// in layer setup:\nconst lastEventId = kv.forSchema(EventId);\n\nconst getLastEventId = Effect.fn(\"StoreEventLog.getLastEventId\")((store: StoreRef) =\u003e\n  KeyValueStore.prefix(lastEventId, storePrefix(store))\n    .get(lastEventIdKey)\n    .pipe(Effect.mapError(toStoreIoError(store.root)))\n);\n\n// in clear():\nyield* KeyValueStore.prefix(lastEventId, prefix).remove(lastEventIdKey);\n```\n\n## Critical Considerations\n- Writes must be atomic (KV guarantees this at key level)\n- Error handling: map KV errors to StoreIoError\n- clear() must remove last-id key to avoid stale data\n- Use Effect.fn() for proper tracing\n\n## Acceptance Criteria\n- [ ] StoreWriter.append() updates events/last-id\n- [ ] StoreEventLog.getLastEventId() returns Option\u003cEventId\u003e\n- [ ] StoreEventLog.clear() removes last-id key\n- [ ] No unsafe Effect patterns used\n- [ ] Compilation succeeds\n- [ ] Follows existing KeyValueStore patterns\n\n## Verification\n```bash\n# Manual test\nbun run src/test-last-event-id.ts\n# Should append event and retrieve last ID\n```\n\n## Related\n- Parent: #1\n- Depends on: skygent-bsky-9ed (domain types)\n- Blocks: skygent-bsky staleness detection","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-26T14:15:04.813354-06:00","updated_at":"2026-01-26T14:15:04.813354-06:00","dependencies":[{"issue_id":"skygent-bsky-uej","depends_on_id":"skygent-bsky-9ed","type":"blocks","created_at":"2026-01-26T14:22:48.89248-06:00","created_by":"daemon"}]}
